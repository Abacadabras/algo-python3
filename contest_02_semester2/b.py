"""B-Ассоциативный массив на хеш-таблице с цепочками - Добавление элемента
Эта задача из серии по реализации ассоциативного массива на хеш-таблице с использованием цепочек для разрешения коллизий.

Вам необходимо создать пустую хеш-таблицу и заполнить её входными значениями.

Для заполнения таблицы рекомендуется реализовать функцию insert(table, key, value) - это будет ваша первая
функция-интерфейс к таблице, позволяющая добавлять новые элементы в таблицу и перезаписывать старые. Другие две функции:
удаление и поиск элемента предстоит сделать в других задачах.

При реализации пользуйтесь хеш-таблицей следующего формата:

hash_table = [
    [], # это пустая цепочка
    [[hash1, key1, value1]], # это цепочка с одним значением
    [[hash2, key2, value2], [hash3, key3, value3]], # это цепочка с двумя значениями
    ...
]
Размер хеш-таблицы возьмите равным 10. Каждой строке таблицы соответствует остаток от деления значения хеш-функции на 10
Ключи и значения в таблице должны иметь строковый тип.

Для генерации хеша воспользуйтесь полиномиальной хеш-функцией со следующими параметрами:

основание 91
модуль 100
Хеш вычисляется только от ключа. В случае коллизии (совпадения хеша по модулю 10) добавляйте элемент в конец цепочки.

Не забудьте, что если элемент уже имеется в таблице, то нужно перезаписать его значение (в элемент с совпавшим ключом).

В качестве ответа необходимо будет распечатать содержимое таблицы (см. Формат выходных данных).

Формат входных данных
Первая строка - натуральное число M, количество элементов на запись в таблицу. Следующие M строк - разделённые пробелом
ключ и значение, которые необходимо внести в таблицу.

Формат выходных данных
Распечатайте непустые цепочки. Печать цепочки выглядит так. Сначала напечатайте индекс цепочки в хеш-таблице. Начиная со
ледующей строки, распечатайте элементы цепочки. Каждый элемент находится на своей строке и представляет собой 3
значения, разделённые пробелом: хеш, ключ, значение."""


def insert(h_table, key, value):

    hash_value = my_hash(91, 100, key)
    el_table = [hash_value, key, value]
    mod = hash_value % 10
    if h_table[mod]:
        is_key = True
        for i in range(len(h_table[mod])):
            if h_table[mod][i][1] == key:  # если находим элемент с тем же ключом, то меняем его на elem
                is_key = False
                h_table[mod][i] = el_table
        if is_key:
            h_table[mod].append(el_table)
    else:
        h_table[mod].append(el_table)


def my_hash(base: int, degree: int, string: str) -> int:

    value = 0
    for i in range(len(string)-1, -1, -1):
        value += ord(string[i]) * base**(len(string)-1-i)

    return value % degree


if __name__ == '__main__':
    hash_table = [[] for _ in range(10)]

    n = int(input())
    for i in range(n):
        k, val = input().split()
        insert(hash_table, k, val)

    for pos, elem in enumerate(hash_table):
        if elem:
            print(pos)
            for i in range(len(elem)):
                print(*elem[i])
