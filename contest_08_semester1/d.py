"""D-Быстрые сортировки - сортировка Тони Хоара
Сортировка Тони Хоара заключается в следующем: - разбиение массива по барьеру - сортировка элементов, меньших барьера
(группа 1) - рекуррентный вызов - сортировка элементов, больших барьера (группа 3) - рекуррентный вызов - пересборка
исходного массива "склеиванием" элементов группы 1, затем элементов, равных барьеру (группа 2) и элементов группы 3

В этой задаче вам необходимо реализовать сортировку Тони Хоара, в которой в качестве барьера используется элемент
массива на позиции 0.

Для написания функции воспользуетсь шаблоном, приведённом ниже. Ваш код должен находиться между вызовами функции print.
Отправлять на проверку нужно всю функцию hoar_sort.

Аргументы функции:
A - список из целых чисел, над которым осуществляется сортировка.
depth - глубина рекурсивного вызова, отсчёт начинает с единицы, не забудьте передать глубину в последующие вызовы.
part - строка, имеющая одно из двух значений: left или right, при рекурсивном вызове сортировки от левой части подавать
значение left, при сортировке правой части - right. Первый вызов считается left.

Возвращаемое значение функции
Функция не возвращает значений. Она производит только печать, как указано в шаблоне и сортирует по возрастанию
массив A (inplace)."""


def hoar_sort(A, depth=1, part='left'):
    print('depth:', depth, 'part:', part, 'array before:', A)

    #  ваша реализация сортировки
    if len(A) <= 1:
        return A

    barrier = A[0]
    left = []
    middle = 0
    right = []
    for num in A:
        if num < barrier:
            left.append(num)
        elif num > barrier:
            right.append(num)
        else:
            middle += 1

    hoar_sort(left, depth+1)
    hoar_sort(right, depth + 1, 'right')

    for ind, num in enumerate(left + [barrier] * middle + right):
        A[ind] = num

    print('depth:', depth, 'part:', part, 'array after:', A)


if __name__ == '__main__':
    hoar_sort([5, 2, 4, 8, 7, 1, 3, 10, 6])
