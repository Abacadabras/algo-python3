"""B-Сортировка слиянием
В этой задаче требуется написать сортировку слиянием inplace.

Для этого напишите функцию merge_sort(A, depth=1, part='left'), осуществляющую сортировку слиянием, и логирующую
состояние вызова.

Ниже показан шаблон функции, используйте его, чтобы лог-сообщения о вызовах соответствовали тем, что в тестах.

Внесённый вами код должен находиться между вызовами print.

Также внимательно прочтите примечания в шаблоне.

Аргументы функции
A - список из целых чисел, над которым осуществляется сортировка.
depth - глубина рекурсивного вызова, отсчёт начинает с единицы, не забудьте передать глубину в последующие вызовы.
part - строка, имеющая одно из двух значений: left или right, при рекурсивном вызове сортировки от левой части подавать
значение left, при сортировке правой части - right. Первый вызов считается left.
Ограничения на функцию
Запрещено использование sort, sorted, append.

Возвращаемое значение функции
Функция не возвращает значений. Она производит только печать, как указано в шаблоне и сортирует по возрастанию массив
A (inplace)."""


def merge_sort(A, depth=1, part='left'):
    print('depth:', depth, '|', 'part:', part, '|', 'array:', A)  # состояние переменных при вызове

    #  ваша реализация сортировки
    #
    #  внимание
    #    разбиение массива производить по индексу len(A) // 2
    #    элемент, стоящий на индексе разбиения, относить к правой части
    #    при рекурсивном вызове сначала сортировать левую часть от разбиения массива, затем правую

    if len(A) == 1:
        return

    n = len(A) // 2
    left_arr = A[:n]
    right_arr = A[n:]

    merge_sort(left_arr, depth + 1)
    merge_sort(right_arr, depth + 1, 'right')
    i = j = k = 0
    while i < len(left_arr) and j < len(right_arr):
        if left_arr[i] < right_arr[j]:
            A[k] = left_arr[i]
            i += 1
        else:
            A[k] = right_arr[j]
            j += 1
        k += 1

    while i < len(left_arr):
        A[k] = left_arr[i]
        i += 1
        k += 1
    while j < len(right_arr):
        A[k] = right_arr[j]
        j += 1
        k += 1

    print('depth:', depth, '|', 'part:', part, '|', 'after merge:', A)  # состояние переменных перед выходом из функции
    #  если функция не вызвала сама себя, состояние переменных перед выходом из функции не должно выводиться,
    #  поскольку гарантированно известно, что массив A в таком случае не изменяется


# if __name__ == '__main__':
#     merge_sort([2, 4, 1, 3, 2, 10])
